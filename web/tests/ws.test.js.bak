import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import BlockWebSocket from '../src/ws.js';
import appState from '../src/state.js';

// Mock WebSocket
class MockWebSocket {
  static CONNECTING = 0;
  static OPEN = 1;
  static CLOSING = 2;
  static CLOSED = 3;

  constructor(url) {
    this.url = url;
    this.readyState = MockWebSocket.CONNECTING;
    this.onopen = null;
    this.onmessage = null;
    this.onerror = null;
    this.onclose = null;
    this.sentMessages = [];

    // Simulate async connection
    setTimeout(() => {
      this.readyState = MockWebSocket.OPEN;
      if (this.onopen) this.onopen({ type: 'open' });
    }, 10);
  }

  send(data) {
    if (this.readyState !== MockWebSocket.OPEN) {
      throw new Error('WebSocket is not open');
    }
    this.sentMessages.push(data);
  }

  close(code = 1000, reason = '') {
    this.readyState = MockWebSocket.CLOSING;
    setTimeout(() => {
      this.readyState = MockWebSocket.CLOSED;
      if (this.onclose) this.onclose({ code, reason, type: 'close' });
    }, 10);
  }

  // Test helper: simulate receiving message
  simulateMessage(data) {
    if (this.onmessage) {
      this.onmessage({
         typeof data === 'string' ? data : JSON.stringify(data),
        type: 'message',
      });
    }
  }

  // Test helper: simulate error
  simulateError(error) {
    if (this.onerror) {
      this.onerror(error);
    }
  }
}

describe('BlockWebSocket', () => {
  let ws;
  let mockWS;

  beforeEach(() => {
    // Mock global WebSocket
    global.WebSocket = MockWebSocket;

    // Reset state
    appState.reset();

    // Clear any existing timers
    vi.clearAllTimers();
  });

  afterEach(() => {
    if (ws && ws.mounted) {
      ws.unmount();
    }
  });

  describe('constructor', () => {
    it('should create instance with default options', () => {
      ws = new BlockWebSocket('ws://localhost:5000/ws');

      expect(ws.url).toBe('ws://localhost:5000/ws');
      expect(ws.reconnectDelay).toBe(1000);
      expect(ws.maxReconnectDelay).toBe(30000);
      expect(ws.connected).toBe(false);
    });

    it('should accept custom options', () => {
      ws = new BlockWebSocket('ws://test:8080', {
        maxReconnectAttempts: 5,
        pingInterval: 10000,
      });

      expect(ws.maxReconnectAttempts).toBe(5);
      expect(ws.pingInterval).toBe(10000);
    });

    it('should register default message handlers', () => {
      ws = new BlockWebSocket('ws://localhost:5000/ws');

      expect(ws.messageHandlers.has('block_update')).toBe(true);
      expect(ws.messageHandlers.has('metrics_update')).toBe(true);
      expect(ws.messageHandlers.has('network_update')).toBe(true);
      expect(ws.messageHandlers.has('trading_update')).toBe(true);
    });
  });

  describe('connect', () => {
    it('should establish WebSocket connection', async () => {
      ws = new BlockWebSocket('ws://localhost:5000/ws');
      ws.mount();

      // Wait for connection
      await new Promise((resolve) => setTimeout(resolve, 20));

      expect(ws.connected).toBe(true);
    });

    it('should update app state on connect', async () => {
      ws = new BlockWebSocket('ws://localhost:5000/ws');
      ws.mount();

      await new Promise((resolve) => setTimeout(resolve, 20));

      const wsState = appState.get('ws');
      expect(wsState.connected).toBe(true);
      expect(wsState.url).toBe('ws://localhost:5000/ws');
    });

    it('should subscribe to streams on connect', async () => {
      ws = new BlockWebSocket('ws://localhost:5000/ws');
      ws.mount();

      await new Promise((resolve) => setTimeout(resolve, 20));

      // Check that subscription messages were sent
      const messages = ws.ws.sentMessages;
      expect(messages.length).toBeGreaterThan(0);

      const subscribeMessages = messages.filter((msg) => {
        const parsed = JSON.parse(msg);
        return parsed.method === 'state_stream.subscribe';
      });

      expect(subscribeMessages.length).toBeGreaterThan(0);
    });

    it('should not connect if already connected', async () => {
      ws = new BlockWebSocket('ws://localhost:5000/ws');
      ws.mount();

      await new Promise((resolve) => setTimeout(resolve, 20));

      const consoleSpy = vi.spyOn(console, 'warn').mockImplementation(() => {});

      ws.connect();

      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('Already connected'),
      );

      consoleSpy.mockRestore();
    });
  });

  describe('message handling', () => {
    beforeEach(async () => {
      ws = new BlockWebSocket('ws://localhost:5000/ws');
      ws.mount();
      await new Promise((resolve) => setTimeout(resolve, 20));
    });

    it('should handle block_update messages', () => {
      const blockData = {
        height: 12345,
        finalized_height: 12340,
        timestamp: Date.now(),
      };

      ws.ws.simulateMessage({
        type: 'block_update',
         blockData,
      });

      const metrics = appState.get('metrics');
      expect(metrics.blockHeight).toBe(12345);
      expect(metrics.finalizedHeight).toBe(12340);
    });

    it('should handle metrics_update messages', () => {
      const metricsData = {
        tps: 1250,
        fees: 42,
        latencyMs: 18,
      };

      ws.ws.simulateMessage({
        type: 'metrics_update',
         metricsData,
      });

      const metrics = appState.get('metrics');
      expect(metrics.tps).toBe(1250);
      expect(metrics.fees).toBe(42);
      expect(metrics.latencyMs).toBe(18);
    });

    it('should handle network_update messages', () => {
      const networkData = {
        peers: 42,
        activeConnections: 38,
      };

      ws.ws.simulateMessage({
        type: 'network_update',
         networkData,
      });

      const network = appState.get('network');
      expect(network.peers).toBe(42);
      expect(network.activeConnections).toBe(38);
    });

    it('should handle trading_update messages', () => {
      const tradingData = {
        volume: 125000,
        lastPrice: 1.42,
      };

      ws.ws.simulateMessage({
        type: 'trading_update',
         tradingData,
      });

      const trading = appState.get('trading');
      expect(trading.volume).toBe(125000);
      expect(trading.lastPrice).toBe(1.42);
    });

    it('should handle pong messages for latency', () => {
      const timestamp = Date.now() - 50; // 50ms ago

      ws.ws.simulateMessage({
        type: 'pong',
        timestamp,
      });

      expect(ws.metrics.latency).toBeGreaterThanOrEqual(45);
      expect(ws.metrics.latency).toBeLessThanOrEqual(60);
    });

    it('should warn on unknown message types', () => {
      const consoleSpy = vi.spyOn(console, 'warn').mockImplementation(() => {});

      ws.ws.simulateMessage({
        type: 'unknown_type',
          {},
      });

      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('No handler for message type: unknown_type'),
      );

      consoleSpy.mockRestore();
    });

    it('should track message metrics', () => {
      expect(ws.metrics.messagesReceived).toBe(0);

      ws.ws.simulateMessage({
        type: 'metrics_update',
         {},
      });

      expect(ws.metrics.messagesReceived).toBe(1);
      expect(ws.metrics.lastMessageTime).toBeDefined();
    });
  });

  describe('send', () => {
    beforeEach(async () => {
      ws = new BlockWebSocket('ws://localhost:5000/ws');
      ws.mount();
      await new Promise((resolve) => setTimeout(resolve, 20));
    });

    it('should send JSON messages', () => {
      const message = { type: "test",  "hello" };

      const result = ws.send(message);

      expect(result).toBe(true);
      expect(ws.ws.sentMessages).toContain(JSON.stringify(message));
      expect(ws.metrics.messagesSent).toBe(1);
    });

    it('should send string messages', () => {
      const message = 'test message';

      const result = ws.send(message);

      expect(result).toBe(true);
      expect(ws.ws.sentMessages).toContain(message);
    });

    it('should fail when not connected', () => {
      ws.connected = false;

      const consoleSpy = vi.spyOn(console, 'warn').mockImplementation(() => {});

      const result = ws.send({ test: 'data' });

      expect(result).toBe(false);
      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('Cannot send, not connected'),
      );

      consoleSpy.mockRestore();
    });
  });

  describe('subscriptions', () => {
    beforeEach(async () => {
      ws = new BlockWebSocket('ws://localhost:5000/ws');
      ws.mount();
      await new Promise((resolve) => setTimeout(resolve, 20));
    });

    it('should subscribe to streams', () => {
      const result = ws.subscribe('custom_stream');

      expect(result).toBe(true);
      expect(ws.subscriptions.has('custom_stream')).toBe(true);
    });

    it('should unsubscribe from streams', () => {
      ws.subscribe('custom_stream');
      const result = ws.unsubscribe('custom_stream');

      expect(result).toBe(true);
      expect(ws.subscriptions.has('custom_stream')).toBe(false);
    });

    it('should resubscribe on reconnect', async () => {
      ws.subscribe('stream1');
      ws.subscribe('stream2');

      // Clear sent messages
      ws.ws.sentMessages = [];

      // Trigger reconnect
      ws.resubscribeAll();

      // Check subscription messages sent
      const messages = ws.ws.sentMessages;
      const subscribeCount = messages.filter((msg) => {
        const parsed = JSON.parse(msg);
        return (
          parsed.method === 'state_stream.subscribe' &&
          (parsed.params.includes('stream1') || parsed.params.includes('stream2'))
        );
      }).length;

      expect(subscribeCount).toBe(2);
    });
  });

  describe('reconnection', () => {
    beforeEach(() => {
      vi.useFakeTimers();
    });

    afterEach(() => {
      vi.useRealTimers();
    });

    it('should reconnect on disconnect', async () => {
      ws = new BlockWebSocket('ws://localhost:5000/ws');
      ws.mount();

      await vi.advanceTimersByTimeAsync(20);

      expect(ws.connected).toBe(true);

      // Simulate disconnect
      ws.ws.close(1006, 'Abnormal closure');

      await vi.advanceTimersByTimeAsync(20);

      expect(ws.connected).toBe(false);
      expect(ws.reconnectAttempts).toBe(0); // Will increment on next attempt

      // Advance to reconnect
      await vi.advanceTimersByTimeAsync(1000);

      expect(ws.reconnectAttempts).toBe(1);
    });

    it('should use exponential backoff', async () => {
      ws = new BlockWebSocket('ws://localhost:5000/ws');
      ws.mount();

      await vi.advanceTimersByTimeAsync(20);

      const initialDelay = ws.reconnectDelay;

      // Simulate disconnect
      ws.ws.close(1006);
      await vi.advanceTimersByTimeAsync(20);

      // Trigger reconnect logic (scheduleReconnect)
      ws.scheduleReconnect();

      expect(ws.reconnectDelay).toBeGreaterThan(initialDelay);
    });

    it('should cap reconnect delay', () => {
      ws = new BlockWebSocket('ws://localhost:5000/ws');

      // Simulate many reconnects
      for (let i = 0; i < 10; i++) {
        ws.scheduleReconnect();
      }

      expect(ws.reconnectDelay).toBeLessThanOrEqual(ws.maxReconnectDelay);
    });

    it('should stop reconnecting after max attempts', () => {
      ws = new BlockWebSocket('ws://localhost:5000/ws', {
        maxReconnectAttempts: 3,
      });

      const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});

      // Exceed max attempts
      ws.reconnectAttempts = 3;
      ws.scheduleReconnect();

      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('Max reconnect attempts reached'),
      );

      consoleSpy.mockRestore();
    });

    it('should not reconnect on clean close', async () => {
      ws = new BlockWebSocket('ws://localhost:5000/ws');
      ws.mount();

      await new Promise((resolve) => setTimeout(resolve, 20));

      // Clean close (code 1000)
      ws.ws.close(1000, 'Normal closure');

      await new Promise((resolve) => setTimeout(resolve, 20));

      expect(ws.reconnectAttempts).toBe(0);
    });
  });

  describe('keepalive', () => {
    beforeEach(() => {
      vi.useFakeTimers();
    });

    afterEach(() => {
      vi.useRealTimers();
    });

    it('should send ping messages', async () => {
      ws = new BlockWebSocket('ws://localhost:5000/ws', {
        pingInterval: 1000,
      });
      ws.mount();

      await vi.advanceTimersByTimeAsync(20);

      // Clear initial messages
      ws.ws.sentMessages = [];

      // Advance past ping interval
      await vi.advanceTimersByTimeAsync(1000);

      const pingMessages = ws.ws.sentMessages.filter((msg) => {
        const parsed = JSON.parse(msg);
        return parsed.type === 'ping';
      });

      expect(pingMessages.length).toBeGreaterThan(0);
    });

    it('should stop pinging on disconnect', async () => {
      ws = new BlockWebSocket('ws://localhost:5000/ws', {
        pingInterval: 1000,
      });
      ws.mount();

      await vi.advanceTimersByTimeAsync(20);

      // Disconnect
      ws.ws.close(1000);
      await vi.advanceTimersByTimeAsync(20);

      // Clear messages
      ws.ws.sentMessages = [];

      // Advance time
      await vi.advanceTimersByTimeAsync(2000);

      // No pings should be sent
      const pingMessages = ws.ws.sentMessages.filter((msg) => {
        try {
          const parsed = JSON.parse(msg);
          return parsed.type === 'ping';
        } catch {
          return false;
        }
      });

      expect(pingMessages.length).toBe(0);
    });
  });

  describe('custom handlers', () => {
    beforeEach(async () => {
      ws = new BlockWebSocket('ws://localhost:5000/ws');
      ws.mount();
      await new Promise((resolve) => setTimeout(resolve, 20));
    });

    it('should register custom message handlers', () => {
      const handler = vi.fn();
      ws.on('custom_type', handler);

      ws.ws.simulateMessage({
        type: 'custom_type',
         { test: 'data' }
      });

      expect(handler).toHaveBeenCalledWith({ test: 'data' }, expect.any(Object));
    });

    it('should unregister message handlers', () => {
      const handler = vi.fn();
      ws.on('custom_type', handler);
      ws.off('custom_type');

      ws.ws.simulateMessage({
        type: 'custom_type',
         {},
      });

      expect(handler).not.toHaveBeenCalled();
    });
  });

  describe('lifecycle', () => {
    it('should connect on mount', async () => {
      ws = new BlockWebSocket('ws://localhost:5000/ws');

      expect(ws.connected).toBe(false);

      ws.mount();

      await new Promise((resolve) => setTimeout(resolve, 20));

      expect(ws.connected).toBe(true);
    });

    it('should disconnect on unmount', async () => {
      ws = new BlockWebSocket('ws://localhost:5000/ws');
      ws.mount();

      await new Promise((resolve) => setTimeout(resolve, 20));

      expect(ws.connected).toBe(true);

      ws.unmount();

      await new Promise((resolve) => setTimeout(resolve, 20));

      expect(ws.connected).toBe(false);
      expect(ws.ws).toBeNull();
    });

    it('should cleanup subscriptions on unmount', async () => {
      ws = new BlockWebSocket('ws://localhost:5000/ws');
      ws.mount();

      await new Promise((resolve) => setTimeout(resolve, 20));

      ws.subscribe('stream1');
      ws.subscribe('stream2');

      expect(ws.subscriptions.size).toBe(2);

      ws.unmount();

      expect(ws.subscriptions.size).toBe(0);
      expect(ws.messageHandlers.size).toBe(0);
    });
  });

  describe('metrics', () => {
    beforeEach(async () => {
      ws = new BlockWebSocket('ws://localhost:5000/ws');
      ws.mount();
      await new Promise((resolve) => setTimeout(resolve, 20));
    });

    it('should track messages sent and received', () => {
      expect(ws.metrics.messagesSent).toBe(0);
      expect(ws.metrics.messagesReceived).toBe(0);

      ws.send({ test: 'data' });
      ws.ws.simulateMessage({ type: "test",  {} });

      expect(ws.metrics.messagesSent).toBe(1);
      expect(ws.metrics.messagesReceived).toBe(1);
    });

    it('should track reconnect count', () => {
      expect(ws.metrics.reconnects).toBe(0);

      ws.scheduleReconnect();

      expect(ws.metrics.reconnects).toBe(1);
    });

    it('should return metrics snapshot', () => {
      const metrics = ws.getMetrics();

      expect(metrics).toHaveProperty('messagesReceived');
      expect(metrics).toHaveProperty('messagesSent');
      expect(metrics).toHaveProperty('reconnects');
      expect(metrics).toHaveProperty('latency');
    });
  });

  describe('connection status', () => {
    it('should report connected status', async () => {
      ws = new BlockWebSocket('ws://localhost:5000/ws');

      expect(ws.isConnected()).toBe(false);

      ws.mount();
      await new Promise((resolve) => setTimeout(resolve, 20));

      expect(ws.isConnected()).toBe(true);
    });
  });
});
